
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neuron Network with Synapses</title>
<style>
  body{margin:0;background:#0b0b10;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(0,0,600);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.DirectionalLight(0xffffff,0.8));
scene.add(new THREE.AmbientLight(0x555555));

let positions=[], colors=[], distances=[], neuronOffsets=[], neuronCenters=[];
const neurons = 50;
const maxDepth = 6;
const baseBranchLen = 18;
const networkSize = 400;
const synapses = [];

// Create neuron structure
function addBranch(x,y,z,dir,depth,dist,neuronIndex){
    if(depth>maxDepth) return;
    const len = baseBranchLen*(0.7 + Math.random()*0.6);
    const nx = x + dir.x*len + (Math.random()-0.5)*4;
    const ny = y + dir.y*len + (Math.random()-0.5)*4;
    const nz = z + dir.z*len + (Math.random()-0.5)*4;

    positions.push(x,y,z,nx,ny,nz);
    colors.push(0,0,0,0,0,0);
    distances.push(dist,dist+len);
    neuronOffsets.push(neuronIndex,neuronIndex);

    const nChildren = depth<2?3:(Math.random()>0.6?2:1);
    for(let i=0;i<nChildren;i++){
        const angle = Math.random()*Math.PI*2;
        const tilt = (Math.random()-0.5)*0.7;
        const ndir = new THREE.Vector3(
            dir.x*0.6 + Math.cos(angle)*0.6 + tilt*0.2,
            dir.y*0.6 + Math.sin(angle)*0.6 + (Math.random()-0.5)*0.2,
            dir.z*0.6 + (Math.random()-0.5)*0.4
        ).normalize();
        addBranch(nx,ny,nz,ndir,depth+1,dist+len,neuronIndex);
    }
}

// Generate neurons
for(let n=0;n<neurons;n++){
    const nx = (Math.random()-0.5)*networkSize;
    const ny = (Math.random()-0.5)*networkSize;
    const nz = (Math.random()-0.5)*networkSize;
    neuronCenters.push(new THREE.Vector3(nx,ny,nz));
    addBranch(nx,ny,nz,new THREE.Vector3(0,1,0),0,0,n);
}

// Geometry for neuron branches
const geom = new THREE.BufferGeometry();
geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions),3));
geom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors),3));
geom.setAttribute('dist', new THREE.BufferAttribute(new Float32Array(distances),1));
geom.setAttribute('neuron', new THREE.BufferAttribute(new Float32Array(neuronOffsets),1));

const material = new THREE.LineBasicMaterial({vertexColors:true, linewidth:1, transparent:true});
const lines = new THREE.LineSegments(geom,material);
scene.add(lines);

// Generate synaptic connections
const synPositions = [];
const synColors = [];
for(let i=0;i<neurons;i++){
    const src = neuronCenters[i];
    const targets = [];
    while(targets.length<3){
        const j = Math.floor(Math.random()*neurons);
        if(j!==i && !targets.includes(j)) targets.push(j);
    }
    for(let t of targets){
        const trg = neuronCenters[t];
        synPositions.push(src.x,src.y,src.z,trg.x,trg.y,trg.z);
        synColors.push(0.2,0.4,1,0.2,0.4,1); // initial blue color
    }
}
const synGeom = new THREE.BufferGeometry();
synGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(synPositions),3));
synGeom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(synColors),3));
const synMat = new THREE.LineBasicMaterial({vertexColors:true,linewidth:1,transparent:true,opacity:0.6});
const synLines = new THREE.LineSegments(synGeom,synMat);
scene.add(synLines);

let mouseX=0, mouseY=0;
document.addEventListener('mousemove', e=>{
    mouseX = (e.clientX/innerWidth -0.5)*2;
    mouseY = (e.clientY/innerHeight -0.5)*2;
});

// Voltage to RGB
function voltageToRgb(v){
    const t = (v+80)/25;
    if(t<0.5){
        const tt = t*2;
        return [0.6*(1-tt)+0.2*tt,0.

    *(1-tt)+0.4*tt,0.8*(1-tt)+1*tt];
    } else {
        const tt = (t-0.5)*2;
        return [0.2*(1-tt)+1*tt,0.4*(1-tt)+0.6*tt,1*(1-tt)+0.15*tt];
    }
}

const colAttr = geom.getAttribute('color');
const distAttr = geom.getAttribute('dist');
const neuronAttr = geom.getAttribute('neuron');

const synColAttr = synGeom.getAttribute('color');

const baseV = -80;
const amp = 25;
const waves = [0.02,0.03,0.015];

function animate(t){
    requestAnimationFrame(animate);
    const time = t*0.001;

    camera.position.x += (mouseX*600 - camera.position.x)*0.05;
    camera.position.y += (-mouseY*400 - camera.position.y)*0.05;
    camera.position.z = 600 + Math.sin(time*0.1)*50;
    camera.lookAt(0,0,0);

    // Update neuron branches
    for(let i=0;i<distAttr.count;i++){
        const d = distAttr.getX(i);
        const neuronIndex = neuronAttr.getX(i);
        let v = baseV;
        for(let w of waves) v += amp/3*Math.sin(time*6 - d*w*6);
        v += amp*0.3*Math.sin(time*3 + neuronIndex*1.5*Math.random());
        const [r,g,b] = voltageToRgb(v);
        colAttr.setXYZ(i,r,g,b);
    }
    colAttr.needsUpdate = true;

    // Update synapses: highlight if source neuron is active
    for(let i=0;i<synColAttr.count;i+=2){
        const srcIndex = Math.floor(i/2)%neurons;
        let v = baseV + amp*0.3*Math.sin(time*3 + srcIndex*1.5*Math.random());
        const intensity = Math.min(Math.max((v+80)/25,0),1);
        synColAttr.setXYZ(i, 0.2*(1-intensity)+1*intensity, 0.4*(1-intensity)+1*intensity, 1*intensity);
        synColAttr.setXYZ(i+1, 0.2*(1-intensity)+1*intensity, 0.4*(1-intensity)+1*intensity, 1*intensity);
    }
    synColAttr.needsUpdate = true;

    renderer.render(scene,camera);
}
animate(0);

window.addEventListener('resize',()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
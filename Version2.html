
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pulsing Neuron Network with Curved Synapses</title>
<style>
  body{margin:0;background:#0b0b10;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(0,0,600);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.DirectionalLight(0xffffff,0.8));
scene.add(new THREE.AmbientLight(0x555555));

let positions=[], colors=[], distances=[], neuronOffsets=[], neuronCenters=[];
const neurons = 50;
const maxDepth = 6;
const baseBranchLen = 18;
const networkSize = 400;

// Build neuron branches
function addBranch(x,y,z,dir,depth,dist,neuronIndex){
    if(depth>maxDepth) return;
    const len = baseBranchLen*(0.7 + Math.random()*0.6);
    const nx = x + dir.x*len + (Math.random()-0.5)*4;
    const ny = y + dir.y*len + (Math.random()-0.5)*4;
    const nz = z + dir.z*len + (Math.random()-0.5)*4;

    positions.push(x,y,z,nx,ny,nz);
    colors.push(0,0,0,0,0,0);
    distances.push(dist,dist+len);
    neuronOffsets.push(neuronIndex,neuronIndex);

    const nChildren = depth<2?3:(Math.random()>0.6?2:1);
    for(let i=0;i<nChildren;i++){
        const angle = Math.random()*Math.PI*2;
        const tilt = (Math.random()-0.5)*0.7;
        const ndir = new THREE.Vector3(
            dir.x*0.6 + Math.cos(angle)*0.6 + tilt*0.2,
            dir.y*0.6 + Math.sin(angle)*0.6 + (Math.random()-0.5)*0.2,
            dir.z*0.6 + (Math.random()-0.5)*0.4
        ).normalize();
        addBranch(nx,ny,nz,ndir,depth+1,dist+len,neuronIndex);
    }
}

// Generate neurons
for(let n=0;n<neurons;n++){
    const nx = (Math.random()-0.5)*networkSize;
    const ny = (Math.random()-0.5)*networkSize;
    const nz = (Math.random()-0.5)*networkSize;
    neuronCenters.push(new THREE.Vector3(nx,ny,nz));
    addBranch(nx,ny,nz,new THREE.Vector3(0,1,0),0,0,n);
}

// Branch geometry
const geom = new THREE.BufferGeometry();
geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
geom.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
geom.setAttribute('dist', new THREE.Float32BufferAttribute(distances,1));
geom.setAttribute('neuron', new THREE.Float32BufferAttribute(neuronOffsets,1));
const material = new THREE.LineBasicMaterial({vertexColors:true, transparent:true});
const lines = new THREE.LineSegments(geom,material);
scene.add(lines);

// Curved synapses
const synCurves = [];
const synColors = [];
const synDivs = 20;
for(let i=0;i<neurons;i++){
    const src = neuronCenters[i];
    const targets = [];
    while(targets.length<3){
        const j = Math.floor(Math.random()*neurons);
        if(j!==i && !targets.includes(j)) targets.push(j);
    }
    for(let t of targets){
        const trg = neuronCenters[t];
        const mid = new THREE.Vector3(
            (src.x+trg.x)/2 + (Math.random()-0.5)*50,
            (src.y+trg.y)/2 + (Math.random()-0.5)*50,
            (src.z+trg.z)/2 + (Math.random()-0.5)*50
        );
        const curve = new THREE.CubicBezierCurve3(src, mid, mid, trg);
        synCurves.push({curve, srcIndex:i});
        for(let k=0;k<=synDivs;k++) synColors.push(0.2,0.4,1);
    }
}
const synPos = new Float32Array(synCurves.length*(synDivs+1)*3);
const synGeom = new THREE.BufferGeometry();
synGeom.setAttribute('position', new THREE.BufferAttribute(synPos,3));
const synColAttr = new THREE.Float32BufferAttribute(synColors,3);
synGeom.setAttribute('color', synColAttr);
const synMat = new THREE.LineBasicMaterial({vertexColors:true,transparent:true,opacity:0.7});
const synLines = new THREE.LineSegments(synGeom,synMat);
scene.add(synLines);

// Interaction
let mouseX=0, mouseY=0;
document.

addEventListener('mousemove', e=>{
    mouseX = (e.clientX/innerWidth -0.5)*2;
    mouseY = (e.clientY/innerHeight -0.5)*2;
});

// Voltage to RGB
function voltageToRgb(v){
    const t = (v+80)/25;
    if(t<0.5){
        const tt = t*2;
        return [0.6*(1-tt)+0.2*tt,0.1*(1-tt)+0.4*tt,0.8*(1-tt)+1*tt];
    } else {
        const tt = (t-0.5)*2;
        return [0.2*(1-tt)+1*tt,0.4*(1-tt)+0.6*tt,1*(1-tt)+0.15*tt];
    }
}

// Attributes
const colAttr = geom.getAttribute('color');
const distAttr = geom.getAttribute('dist');
const neuronAttr = geom.getAttribute('neuron');

const baseV = -80;
const amp = 25;
const waves = [0.02,0.03,0.015];
const neuronPulse = new Array(neurons).fill(0);

// Animate
function animate(t){
    requestAnimationFrame(animate);
    const time = t*0.001;

    // Camera
    camera.position.x += (mouseX*600 - camera.position.x)*0.05;
    camera.position.y += (-mouseY*400 - camera.position.y)*0.05;
    camera.position.z = 600 + Math.sin(time*0.1)*50;
    camera.lookAt(0,0,0);

    // Random neuron spikes
    for(let n=0;n<neurons;n++){
        if(Math.random()<0.002) neuronPulse[n]=1;
        neuronPulse[n]*=0.95;
    }

    // Branches
    for(let i=0;i<distAttr.count;i++){
        const d = distAttr.getX(i);
        const neuronIndex = neuronAttr.getX(i);
        let v = baseV;
        for(let w of waves) v += amp/3*Math.sin(time*6 - d*w*6);
        v += amp*0.3*Math.sin(time*3 + neuronIndex*1.5*Math.random());
        v += neuronPulse[neuronIndex]*amp*0.5;
        const intensity = Math.min(Math.max((v+80)/25,0),1);
        const [r,g,b] = voltageToRgb(v);
        colAttr.setXYZ(i,r*intensity,g*intensity,b*intensity);
    }
    colAttr.needsUpdate = true;

    // Curved synapses
    let ptr=0;
    for(let sc of synCurves){
        const {curve, srcIndex} = sc;
        for(let i=0;i<=synDivs;i++){
            const t1=i/synDivs;
            const pos = curve.getPoint(t1);
            synPos[ptr++] = pos.x;
            synPos[ptr++] = pos.y;
            synPos[ptr++] = pos.z;
            const intensity = Math.min(Math.max(neuronPulse[srcIndex]*0.5 + 0.5*Math.sin(time*5 - t1*6),0),1);
            synColAttr.setXYZ(i + synCurves.indexOf(sc)*(synDivs+1), 0.2*(1-intensity)+1*intensity, 0.4*(1-intensity)+1*intensity, 1*intensity);
        }
    }
    synGeom.attributes.position.needsUpdate = true;
    synColAttr.needsUpdate = true;

    renderer.render(scene,camera);
}
animate(0);

window.addEventListener('resize',()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>